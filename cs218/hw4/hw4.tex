
\documentclass[11pt]{article}

\usepackage{fullpage,epsfig,latexsym,picinpar,amsbsy,amsmath,algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{xspace}

\input{../macros.tex}

\newcommand{\Greedy}{\mbox{\sc Greedy}}
\newcommand{\Optimum}{\mbox{\sc Optimum}}
\pagestyle{empty}
\begin{document}

\centerline{\large \bf CS218 ASSIGNMENT 4}
\centerline{due Thursday, March 7, at 5PM}

\vskip 0.1in
\noindent
{\bf Individual assignment: Problems 1,2}

\noindent
{\bf Group assignment: Problems 1,2,3}

\vskip 0.1in

%%%%%%%%%%%%%%%%%%%%%%%%%%%%


\begin{problem}
You are about to go backpacking with a friend and you have to spread the load fairly among your two backpacks. You have $n$ items, with item $i$ having weight $w_i$. Your goal is to assign each item to backpack 1 or backpack 2 to minimize the maximum load. Consider the following algorithm:
%
\begin{description}
\item{{\Greedy}:} Consider items in order $i=1,\dots,n$. At step $i$ assign item $i$ to the backpack whose current load is light:est.
\end{description}
%
If $Y$ is a solution (a partition of the items between the two backpacks) by $w(Y)$ we denote its value, that is the weight of the heavier backpack.

Consider the solution $X$ computed by {\Greedy} and the optimum solution $X^\ast$.

\noindent
(a) Prove that $w(X)\le 2\cdot w(X^\ast)$. (5 points.)

\noindent
(b) Prove that $w(X) \le 1.5\cdot w(X^\ast)$. (7 points.)

If you do (b), do not do (a).

\noindent
(c) Show that there is an instance for which the bound in (b) is tight.
(3 points.) 
\end{problem}

\paragraph{Answer:}\mbox{} \\
Suppose that the load in backpack 1 is always no less than backpack 2.\newline
(a). Assume that the total weight of all the items is $W$. The worst case of $w(X)$ is that it is infinitly close to $W$. Since $X^\ast$ is the optimal solution, the items should be assigned to the backpacks as evenly as possible. So, $w(X^\ast)$ cannot be smaller than the half of $W$.
\newline
(b). The worst case will happen when the difference between $X$ and $X^\ast$ is maximized. Worst case: the first $k$ items in backpack 1 overlap in $X$ and $X^\ast$, the difference start from the $k+1$ $th$ item. \newline
\textbf{Why a worst case has to come from this situation?}\newline
Before $k+1$ $th$ item is pushed to either backpack, $X$ is an optimum, which is the same as $X^\ast$. If the $k+1$ $th$ item has a weight much bigger than the previous $k$ items, and it is assigned to backpack 1, then satrting from $k+2$ $th$ item, the following items have to be assigned to backpack 2 to compensate the difference caused at the $k+1$ $th$ item.
The worst case can be simplified to a unit case: $n-1$ items with small weight, and one item with large weight. Assume that the first $n-1$ items;s weight is $a$ each, and the last one has a weight of $m \cdot a$. \newline
{\Greedy}:
\begin{gather*}
    bp1 \gets \frac{n}{2} \cdot a + m \cdot a   \\
    bp2 \gets \frac{n}{2} \cdot a               \\
\end{gather*}
{\Optimum}:\newline
If $m > n$:
\begin{gather*}
    bp1^ \gets m \cdot a                     \\
    bp2 \gets n \cdot a                     \\
\end{gather*}
If $m \leq n$:
\begin{gather*}
    bp1 \gets \frac{n-m}{2} \cdot a + m \cdot a   \\
    bp2 \gets \frac{n-m}{2} \cdot a + m \cdot a   \\
\end{gather*}
Then we can get the relationship between $w(X)$ and $w(X^\ast)$.\newline
If $m > n$:
\begin{gather*}
    w(X) \gets \frac{n}{2} \cdot a + m \cdot a  \\
    w(X^\ast) \gets m \cdot a                   \\
    \frac{w(X)}{w(X^\ast)} = \frac{n + 2 \cdot m}{2 \cdot m} < \frac{3 \cdot m}{2 \cdot m} = 1.5
\end{gather*}
If $m \leq n$:
\begin{gather*}
    w(X) \gets \frac{n}{2} \cdot a + m \cdot a          \\
    w(X^\ast) \gets \frac{n-m}{2} \cdot a + m \cdot a   \\
    \frac{w(X)}{w(X^\ast)} = \frac{n + 2 \cdot m}{n + m} = 1 + \frac{m}{n + m} \leq 1 + \frac{m}{2 \cdot m} = 1.5
\end{gather*}
(c). Consider we have a set of items: $n-1$ items weight a, and one item weights $(n-1) \cdot a$. \newline
According to {\Greedy}, the load of backpack 1 is $\frac{n}{2} \cdot a + (n-1) \cdot a = \frac{3(n-1)}{2} \cdot a$. The load of  the second backpack is $(n-1) \cdot a$. Then $w(X) = \frac{3(n-1)}{2} \cdot a$.
The optimal solution $w(X^\ast)$ is: $(n-1) \cdot a$. \newline
In this case, $w(X) = 1.5\cdot w(X^\ast)$.

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
We are given a weighted complete bipartite graph $G = (L,R,L\times R)$, where $L = \braced{x_1,\dots,x_n}$, $R = \braced{ y_1,\dots,y_m}$, with $n \le m$. By $w_{i,j}$ we denote the weight of edge $(x_i,y_j)$.

An \emph{agreeable} matching $M$ is a matching between $L$ and $R$ in which no two edges ``cross". More specifically, if $i<j$ and $(x_i,y_k), (x_j,y_l)\in M$ then $k < l$. The weight of $M$ is the sum of weights of the edges in $M$.

Give an efficient algorithm that computes a perfect agreable matching in $G$ of minimum weight (``perfect" means that each $x_j$ is matched.)

\noindent Hint: Dynamic programming.
\end{problem}

\paragraph{Answer:}\mbox{} \\
\textbf{Subproblem:}
The agreeable matching in the sub-bipartite of graph $G$.\newline
We can use a table $w$ to store the vertices connection of the bipartite. The size of $w$ is $|X|$ by $|Y|$. The value of $w[i][j]$ is the weight of edge $(x_i,y_j)$. If there is no edge $(x_i,y_j)$, then the value of $w[i][j]$ is infinite.
At each edge, we decide to choose it or not, then we store the total weight in a new table $M$ of the same size as $w$.\newline
We only need to consider the upper diagonal part of the table for "not-cross" and "perfect" constraints, and also the bipartite is complete. The reason why we don't need to consider the lower diagonal part is that each $x_i$ should be matched. The indexes in the lower part satisfies $i>j$, which cannot guarantee that every vertix in $X$ is matched. \newline
\textbf{Recursion:}
\begin{gather*}
    M_{i,j} = min(M_{i-1,j-1}+w_{i,j}, M_{i,j-1})
\end{gather*}
\begin{algorithm}
    \begin{algorithmic}[1]
    \caption{Perfect Agreeable Matching}
        \State $\textbf{Input: } \text{table of weights } \textit{w[1,...,m][1,...,n]}$
        \State $\textit{m} \gets \text{length of } \textit{X}$
        \State $\textit{n} \gets \text{length of } \textit{Y}$
        \State \text{create a table } $M[0,...,m][0,...,n]$
        \For{$j \gets 0$ to $n$}
            \State $M_{0,j} \gets$ $min(w_{1,:})$
        \EndFor
        \For{$i \gets 1$ to $m$}
            \State $M_{i,i-1} \gets \infty$
        \EndFor
        \For{$i \gets 1$ to $m$}
            \For{$j \gets 1$ to $n$}
                \State $M_{i,j} = min(M_{i-1,j-1}+w_{i,j}, M_{i,j-1})$
            \EndFor
        \EndFor
        \Return $M_{m,n}$
    \end{algorithmic}
\end{algorithm}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Bob sells two types of ice cream: vanilla and chocolate. He has an ice cream machine that can produce vanilla ice cream at cost $\$ V$/gallon and chocolate ice cream at cost $\$ C$/gallon. However, resetting the machine from producing vanilla to chocolate icea cream, or vice versa, costs $\$ R$.
He can produce ice cream without using his machine, but then it costs $\$ V'$/gallon for vanilla and $\$ C'$/gallon for chocolate ice cream. (Typically, $V' > V$ and $C' > C$.) Give an algorithm that, for a  given a sequence of orders $o_1\dots o_n$, where each $o_i \in\braced{v,c}$ is an order for a gallon of vanilla or chocolate, computes the minimum
cost of realizing these orders.
\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\vskip 0.3in
\paragraph{Submission.}
Submit the pdf file via gradescope by 5PM on Thursday, March~7. For pair assignments, submit one pdf only with two names on it.

\end{document}

