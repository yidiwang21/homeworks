
\documentclass[11pt]{article}

\usepackage{fullpage,latexsym,picinpar,amsbsy,amsmath, algorithm,amssymb}
\usepackage[noend]{algpseudocode}
\usepackage{xspace}

\input{../macros.tex}

\pagestyle{empty}
\begin{document}

\centerline{\large \bf CS218 ASSIGNMENT 5}
\centerline{due Thursday, March 14, at 5PM}

\vskip 0.2in
\noindent
{\bf Individual assignment: Problem 1, 2}

\noindent
{\bf Group assignment: Problems 1, 2, 3}

\vskip 0.1in

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Give an efficient algorithm that, given a set $X =\{x_1,\dots,x_n\}$ of points on the real line, ordered from left to right, and a number $c > 0$,
determines the smallest set of length-$c$ closed intervals that together contain all points in $X$. Prove the correctness of your algorithm. 
Give its running time and justify your answer. (Again, we assume that the points are already given in increasing order, so they don't need to be sorted.) 

\noindent\emph{Hint: Similar to activity selection.}
\end{problem}

\paragraph{Answer:}\mbox{} \\
\textbf{Greedy choice: }Let's choose the first closed interval starting from the first point in set X, which is $[x_1, x_1+c]$. Then we check whether there is any point in $X$ covered by this interval, if yes, supposing that the last covered point is $x_i$, we do the same thing starting from $x_{i+1}$; if no, we just continue iteration at $x_2$. \newline
We only need one pass the input point set, so running time is $O(n)$.\newline
\textbf{Correctness: }Suppose that the computed solution of the above greedy choice is $S$, and there is an optimal solution $S'$. If $S'$ equals $S$ , then we are done. If not, suppose that preceeding point $x_i$, $S$ and $S'$ overlap. After $x_i$, $S$ contains an interval $[x_{i+1}, x_{i+1}+c]$, but $S'$ contains a different interval $[y_{i+1}, y_{i+1}+c]$. If we replace this interval in $S'$ by what is in $S$, this operation will not affect the subsequences in $S'$, since $y_{i+1}$ must be smaller than $x_{i+1}$. Then we can do this iteratively, and finally make $S'$ equal to $S$; therefore, $S$ is an optimal solution.

\begin{algorithm}
    \begin{algorithmic}[1]
    \caption{Smallest Set of Intervals}
        \State $\textbf{Input: } X =\{x_1,\dots,x_n\}$
        \State $i \gets 0$
        \State $C \gets \emptyset$
        \While {$X \text{ is not empty}$}
            \State $\text{add closed interval } [x_i, x_i+c] \text{ to } C$
            \State $j \gets 0$
            \While {$x_j \leq x_i+c$}
                \State $\text{remove } x_j \text{ from } X$    
                \State $j \gets j+1$
            \EndWhile
            \State $i \gets i+1$
        \EndWhile
        \Return $C$
    \end{algorithmic}
\end{algorithm}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
Call two integer sequences $A = a_1,a_2,...,a_k$ and $B = b_1,b_2,...,b_k$ \emph{resemblant}  if $|a_i - b_i| \le 1$ for all $i$. In other words, the sequences have the same length and  in each position their values differ by at most $1$. The \emph{distance} between two such sequences $A$ and $B$ is defined by $\delta(A,B) = \sum_{i=1}^k |a_i - b_i|$. Note that $0 \le \delta(A,B)\le k$.

Design an efficient algorithm that, given two integer sequences $X = x_1,x_2,...,x_m$ and $Y = y_1,y_2,...,y_n$ and some integer $d\ge 0$, 
finds resemblant subsequences $A$ of $X$ and $B$ of $Y$ that satisfy $\delta(A,B) \le d$ 
and have maximum length. Justify its correctness.  State and justify its time and space complexity.  

\noindent\emph{Hint: Similar to LCS.}
\end{problem}

<<<<<<< HEAD
\paragraph{Answer:}\mbox{} \\


=======
\paragraph{Answer: }\mbox{} \\
This problem is similar to LCS. The difference is that we can keep two tables: the first one stores the distances, and the second one stores the length of resemblant sequences. \newline
\textbf{Recurrence: }
\begin{gather*}
    R_{i,j} \gets R_{i-1,j-1} + 1
\end{gather*}
\textbf{Correctness: }The correctness can be proved by claiming that every entry of the table is computed correctly, then using induction to prove over the algorihtm execution. \newline
\text{Claim: }For all $i \in \{0,..,m\}$ and $j \in \{0,..,n\}$, $R_{i,j} = Resemblant[X^i, Y^j]$. \newline
\text{Proof of Claim: }\newline
When $i = 0$, $j = 0$, $R_{i,j} = 0$ is obviously correct, which is the basic case. Consider some entry $R_{i,j}$, and assume that for all $i' + j' < i + j$, the claim holds for $R_{i',j'}$. Let $\{A^i, B^j\}$ be the solution of $\{X^i, Y^j\}$. \newline
If $|x_i - y_j| \leq 1$, according to the reccurence, the remainder of $I$ must be the longest resemblant sequences of $X^{i-1}$ and $Y^{j-1}$. Then it will induct to $R_{i,j} \gets R_{i-1,j-1} + 1$, which is our induction hypothesis.
Otherwise, let $(c_a, c_b)$ be the last pair in the solution. If $c_a \neq X_i$, then $\{A^i, B^j\}$ must be the solution for $\{X^{i-1}, Y^j\}$. Similarly, If $c_b \neq Y_j$, then $\{A^i, B^j\}$ must be the solution for $\{X^i, Y^{j-1}\}$. Either $R_{i,j} = R_{i-1,j}$ or $R_{i,j} = R_{i,j-1})$ must be correct. Taking $R_{i,j} = max(R_{i-1,j}, R_{i,j-1})$ gives an correct solution. \newline
\textbf{Running time: }Time complexity: $O(n^2)$. Space complexity: $O(1)$.
>>>>>>> f0f2a4cf54b996fbe0949154c4ffc42e0bca62bb

\begin{algorithm}
    \begin{algorithmic}[1]
        \caption{Resemblant Sequences}
        \State $\textbf{Input: } X =\{x_1,\dots,x_m\}$, $Y =\{y_1,\dots,y_n\}$, $d$
        \State $m \gets |X|$, $n \gets |Y|$
        \State create a table $D[0,1,...,m][0,1,...,n]$ to store distances
        \State create a table $R[0,1,...,m][0,1,...,n]$ to store length of resemblant sequences
        \For{$i \gets 0$ to $m$}
            \State $D_{i,0} \gets 0$
            \State $R_{i,0} \gets 0$
        \EndFor
        \For{$j \gets 0$ to $n$}
            \State $D_{0,j} \gets 0$
            \State $R_{0,j} \gets 0$
        \EndFor
        \For{$i \gets 1$ to $m$}
            \For{$j \gets 1$ to $n$}
                \If{$D_{i,j} < d$}
                    \If{$|X_i - Y_j| \leq 1$}
                        \State $R_{i,j} \gets R_{i-1,j-1} + 1$
                        \State $D_{i,j} \gets D_{i-1,j-1} + |X_i - Y_j|$
                    \Else
                        \State $R_{i,j} \gets max(R_{i-1,j}, R_{i,j-1})$
                        \State $D_{i,j} \gets max(D_{i-1,j}, D_{i,j-1})$
                    \EndIf
                \EndIf
            \EndFor
        \EndFor
        \For{$i \gets m$ to $0$}
            \For{$j \gets m$ to $0$}
                \If{$D_{i,j} \leq d$}
                    \Return $R_{i,j}$
                \EndIf
            \EndFor
        \EndFor
    \end{algorithmic}
\end{algorithm}


\newpage
%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{problem}
We are given $n$ items numbered $1,2,...,n$, each item $i$ with size $s_i$ and value $v_i$ (both values are non-negative integers). We are also given some threshold value $V$. We want to determine the minimum size of a knapsack sufficient to pack a subset of items with total value at least $V$ (also a non-negative
integer). More formally, we need to compute a subset $I \subseteq \braced{1,2,...,n}$ such that $v(I) = \sum_{i\in I} v_i \ge V$ and $s(I) = \sum_{i\in I} s_i$ is minimized.
Give an efficient algorithm for this problem. State and justify its time and space complexity. 
(Here, ``efficient'' means that the algorithm is fast if the numbers $v_i$ are not too large.) 

\noindent\emph{Hint: Similar to Knapsack.} 
\end{problem}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%








\vskip 0.3in
\paragraph{Submission.}
Submit the pdf file via gradescope by 5PM on Thursday, March~14.
For pair assignments, submit one pdf only with two names on it.

\end{document}

